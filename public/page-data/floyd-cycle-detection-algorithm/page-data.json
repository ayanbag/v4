{"componentChunkName":"component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx","path":"/floyd-cycle-detection-algorithm","result":{"data":{"post":{"__typename":"MdxPost","slug":"/floyd-cycle-detection-algorithm","title":"Floyd Cycle Detection Algorithm","date":"19.05.2020","tags":[{"name":"Algorithms","slug":"algorithms"}],"description":null,"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Floyd Cycle Detection Algorithm\",\n  \"date\": \"2020-05-19T00:00:00.000Z\",\n  \"tags\": [\"Algorithms\"]\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h3\", null, \"What is Loop in Linked List ?\"), mdx(\"p\", null, \"Generally, the last node of a Linked List points to \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"null\"), \", which indicates that it is end of the list. But when there is a loop in a Linked List , the last node points to some of the interval node or first node or itself. In this case with we traverse a Linked List node one by one, our traversal will never end as it is in loop\"), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"https://user-images.githubusercontent.com/28982255/82292403-7a255f80-99c8-11ea-805c-2279f6544dd6.png\",\n    \"alt\": \"Loop in Linked List\"\n  }))), mdx(\"h3\", null, \"Detection of Loop in Linked List\"), mdx(\"p\", null, \"There are many ways for detecting any cycle in linked list, \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Floyd Cycle Detection Algorithm\"), \" works better than other in terms of Time Complexity and Space Complexity. It is a pointer algorithm which uses only two pointers, which moves through the sequence. It is also called \\\"tortoise and the hare algorithm\\\".\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Space Complexity of Floyd Cycle Detection Algorithm :\"), \" O(1)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Time Complexity of Floyd Cycle Detection Algorithm :\"), \" O(n)\")), mdx(\"h3\", null, \"Working of Floyd Cycle Detection Algorithm and its Mathematical Proof\"), mdx(\"p\", null, \"The logic of this algorithm can be illustrated as a race between a hare and a tortoise. Hare is always faster than a tortoise and it will always win the race against tortoise unless their is a cycle in the race track. If it exists in the race track, race will continue forever and hare will see tortoise again and again.\"), mdx(\"p\", null, \"Lets understand with the help of experiment :\"), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"https://user-images.githubusercontent.com/28982255/82298242-76e2a180-99d1-11ea-9dae-33449dcbbe0e.png\",\n    \"alt\": \"identify-start-node-of-loop-in-circular- linked-list 1\"\n  }))), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Assuming the distance between the beginning node or head node of Linked List and starting node of the loop is \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"a\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Assuming the distance between the starting node of the loop and meeting node of \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"hare\"), \" and \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"tortoise\"), \" is \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"b\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Assuming the distance between the meeting node of \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"hare\"), \" and \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"tortoise\"), \" and starting node  of the loop is \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"c\"))), mdx(\"p\", null, \"Tortoise moves one node at a time and the hare moves two node at same time. So, we can say when the tortoise has moved distance \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"d\"), \" , then turtle has moved pointer \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"2d\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-latex\"\n  }), \"So the length of the loop is b+c\\n\\nWhen both tortoise and hare meets, tortoise covers a distance d = a+b and\\nhare covers a distace 2d = (a+b+c+b)\\n\\nTherefore,\\n2*d = (a+b+c+b)\\nd = (a+b)\\n\\nNow,\\n=> 2*d = 2*(a+b)\\n=> 2*(a+b) = (a+b+c+b)\\n=> 2*a + 2*b = a+2*b+c\\n=> a=c\\n\\nIt means distance from head node to the start of loop node is same as distance between meeting point of the tortoise and hare to the starting node of loop\\n\")), mdx(\"p\", null, \"So this shows after getting meeting point, if one pointer is placed at the beginning of the list, then moving both pointer one node at a time then they will meet at the start of loop.\"), mdx(\"h3\", null, \"Implementation of Floyd Cycle Detection Algorithm\"), mdx(\"p\", null, \"Implementation in \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Python\"), \"  \"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\"\n  }), \"\\n# Node class\\nclass Node:\\n    # Constructor to initialize the node object\\n    def __init__(self, data):\\n        self.data = data\\n        self.next = None\\nclass LinkedList:\\n    # Function to initialize head\\n    def __init__(self):\\n        self.head = None\\n    # Function to insert a new node at the beginning\\n    def push(self, new_data):\\n        new_node = Node(new_data)\\n        new_node.next = self.head\\n        self.head = new_node\\n    # Utility function to print it the linked LinkedList\\n    def printList(self):\\n        temp = self.head\\n        while(temp):\\n            print (temp.data,)\\n            temp = temp.next\\n    def detectLoop(self):\\n        slow_p = self.head\\n        fast_p = self.head\\n        while(slow_p and fast_p and fast_p.next):\\n            slow_p = slow_p.next\\n            fast_p = fast_p.next.next\\n            if slow_p == fast_p:\\n                print (\\\"Found Loop\\\")\\n                return\\n# Driver program for testing\\nllist = LinkedList()\\nllist.push(20)\\nllist.push(4)\\nllist.push(15)\\nllist.push(10)\\n# Create a loop for testing\\nllist.head.next.next.next.next = llist.head\\nllist.detectLoop()\\n\")), mdx(\"p\", null, \"Output :\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"Found Loop\\n\")), mdx(\"h3\", null, \"Live Code\"), mdx(\"p\", null, \"Try the above code\"), mdx(\"iframe\", {\n    height: \"500px\",\n    width: \"100%\",\n    src: \"https://repl.it/@ayanbag/floyd-cycle-detection?lite=true\",\n    scrolling: \"no\",\n    frameBorder: \"no\",\n    allowtransparency: \"true\",\n    allowFullScreen: \"true\",\n    sandbox: \"allow-forms allow-pointer-lock allow-popups allow-same-origin allow-scripts allow-modals\"\n  }));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"What is Loop in Linked List ? Generally, the last node of a Linked List points to  null , which indicates that it is end of the list. Butâ€¦","timeToRead":1,"banner":null}},"pageContext":{"slug":"/floyd-cycle-detection-algorithm","formatString":"DD.MM.YYYY"}}}