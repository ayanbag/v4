{"componentChunkName":"component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx","path":"/sieve-of-eratosthenes-algorithm-the-ancient-algorithm","result":{"data":{"post":{"__typename":"MdxPost","slug":"/sieve-of-eratosthenes-algorithm-the-ancient-algorithm","title":"Sieve of Eratosthenes Algorithm - the ancient algorithm","date":"26.05.2020","tags":[{"name":"Algorithms","slug":"algorithms"}],"description":null,"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Sieve of Eratosthenes Algorithm - the ancient algorithm\",\n  \"date\": \"2020-05-26T00:00:00.000Z\",\n  \"tags\": [\"Algorithms\"]\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Sieve of Eratosthenes\"), \" is a simple and ancient algorithm to find thr prime number up to a given limit. This is one of the most efficient algorithm to find small prime numbers. This algorithm for collecting primes numbers is invented by Eratosthenes (276 - 194 BC).\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Time Complexity\"), \" of Sieve of Eratosthenes : O(n log(log n))\"), mdx(\"p\", null, \"For the given value of n, the algorithm works iteratively making the multiples of primes as composite, starting from 2. Once all the multiple of 2 have been marked as composite, the multiple of the next prime, i.e 3 are marked composite. This process go on until\"), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"https://user-images.githubusercontent.com/28982255/82886000-89298600-9f63-11ea-881d-8bf30b6c0eb7.png\",\n    \"alt\": \"955558e6ac3d6a1c1bc8d3c8b8534aca 1\"\n  }))), mdx(\"p\", null, \"where p is a prime number.\"), mdx(\"h3\", null, \"Working of Sieve of Eratosthenes Algorithm\"), mdx(\"p\", null, \"Here in the algorithm, 0 is represent as a composite number.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"To find all the prime number up-to \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"n\"), \" , we have to generate a list of integers from \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"2 to n\"), \". \", \"[Because the first and smallest prime number is 2]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Initially, let p equal 2, the first prime number.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Now we have to mark all the multiple of p which are less than n as composite, i.e replacing the number in the generated list with 0 \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"except p itself\"), \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Assign the value of p to the next prime number.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Repeat the process until \")), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"https://user-images.githubusercontent.com/28982255/82886000-89298600-9f63-11ea-881d-8bf30b6c0eb7.png\",\n    \"alt\": \"955558e6ac3d6a1c1bc8d3c8b8534aca 1\"\n  }))), mdx(\"p\", null, \"When the algorithm terminates, all the numbers in the list that are not marked are prime.\"), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"https://user-images.githubusercontent.com/28982255/82891130-deb56100-9f6a-11ea-8743-09d63deb4765.gif\",\n    \"alt\": \"soe1\"\n  }))), mdx(\"h3\", null, \"Implementation with an Example\"), mdx(\"p\", null, \"Problem :  Generate all the primes less than 11\"), mdx(\"p\", null, \"Solution : \"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\"\n  }), \"import math\\nn = 200 # n is any arbitrary integer\\nList = []\\nfor x in range(2, n): # add numbers from 2 to n - 1 to List\\n    List.append(x)\\n# note the above statement is equivalent to List = range(2, n)\\np = 2 # p is a prime\\nwhile not int(math.sqrt(p)) + 1 > n: # continue to mark out primes until square root of p is less than n\\n    for x in range(p * 2, n, p): # remove all the multiples of p\\n        List[x - 2] = 0\\n    p += 1\\n    while p - 2 < len(List) and List[p - 2] == 0: # assign p to the next prime. Next prime is the next non zero number in the list\\n        p += 1\\nfor x in List: # search for non zero or prime numbers in the list and print them\\n    if x != 0:\\n        print (x)\\n\")), mdx(\"h3\", null, \"Live Code\"), mdx(\"p\", null, \"Try the above code\"), mdx(\"iframe\", {\n    height: \"500px\",\n    width: \"100%\",\n    src: \"https://repl.it/@ayanbag/seive?lite=true\",\n    scrolling: \"no\",\n    frameBorder: \"no\",\n    allowtransparency: \"true\",\n    allowFullScreen: \"true\",\n    sandbox: \"allow-forms allow-pointer-lock allow-popups allow-same-origin allow-scripts allow-modals\"\n  }));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"Sieve of Eratosthenes  is a simple and ancient algorithm to find thr prime number up to a given limit. This is one of the most efficientâ€¦","timeToRead":1,"banner":null}},"pageContext":{"slug":"/sieve-of-eratosthenes-algorithm-the-ancient-algorithm","formatString":"DD.MM.YYYY"}}}