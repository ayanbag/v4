{"componentChunkName":"component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx","path":"/ramer-douglas-peucker-algorithm","result":{"data":{"post":{"__typename":"MdxPost","slug":"/ramer-douglas-peucker-algorithm","title":"Ramer–Douglas–Peucker Algorithm","date":"16.05.2020","tags":[{"name":"Algorithms","slug":"algorithms"}],"description":null,"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Ramer–Douglas–Peucker Algorithm\",\n  \"date\": \"2020-05-16T00:00:00.000Z\",\n  \"tags\": [\"Algorithms\"]\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"The \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Ramer\\u2013Douglas\\u2013Peucker Algorithm\"), \" is a an algorithms that reduce the number of points that is approximated by a series of points. It is also known as the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Douglas\\u2013Peucker algorithm\"), \" and \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"iterative end-point fit algorithm\"), \". In simple words, it represent a complex line with fewer points in a visually proper way.\"), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"https://user-images.githubusercontent.com/28982255/82112521-2c5feb80-976b-11ea-8dbe-9b59d4b922ad.png\",\n    \"alt\": \"503cdff1-influxdata1\"\n  })), \"\\n\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Original dataset (right) and reduced output (left) from Ramer-Douglas-Peucker Algorithm. Image from NAMEKDEV.\")), mdx(\"h3\", null, \"Overview\"), mdx(\"p\", null, \"The main purpose of this algorithm is to find a similar curve with fewer points for a given curve composed of line segments (also called \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Polylines\"), \"). This algorithm define 'disimilar' based on the maxium distance between the original curve and the simplied curve, i.e. the Hausdroff Distance. The simplified curve consist of a subset of points that defined the original curve. The Ramer\\u2013Douglas\\u2013Peucker Algorithm is most commonly used in geospatial visualizations, like Google Maps, but also useful for other in-browser visualizations as well.\"), mdx(\"h3\", null, \"Working of Ramer\\u2013Douglas\\u2013Peucker Algorithm\"), mdx(\"p\", null, \"In order to use this algorithms, the user must the epsilon ( \\u03B5 ), a threshold limit that is used to determine which point to determine and discard, and it should be a value greater than zero.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Step-1\"), \" :  This algorithms stored the first and the last point of the curve and then it draws the shortest line from the bookend points.\"), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"https://user-images.githubusercontent.com/28982255/82113093-e3129a80-9770-11ea-8a47-96a5d8038546.png\",\n    \"alt\": \"c3044882-influxdata3\"\n  }))), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Step-2\"), \":  Its determine the point farthest point from the line segment with the first and last points as end points.\"), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"https://user-images.githubusercontent.com/28982255/82113113-fcb3e200-9770-11ea-828b-7b90e7a3db5e.png\",\n    \"alt\": \"473bcfba-influxdata4\"\n  }))), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Step-3\"), \": Any points within the epsilon distance from this line will be removed and the approximation will be drawn.\"), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"https://user-images.githubusercontent.com/28982255/82113127-17865680-9771-11ea-9eee-734a77da4f58.png\",\n    \"alt\": \"bd5f4e41-influxdata5\"\n  }))), mdx(\"p\", null, \"The process repeats recurcively until the new approximation for the polyline has been formed.\"), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"https://user-images.githubusercontent.com/28982255/82113279-7ef0d600-9772-11ea-84c5-0e28e4938f38.gif\",\n    \"alt\": \"rdp\"\n  }))), mdx(\"h3\", null, \"Pseudocode\"), mdx(\"p\", null, \"The Pseudocode of Ramer\\u2013Douglas\\u2013Peucker Algorithm :\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"function DouglasPeucker(PointList[], epsilon)\\n    // Find the point with the maximum distance\\n    dmax = 0\\n    index = 0\\n    end = length(PointList)\\n    for i = 2 to (end - 1) {\\n        d = perpendicularDistance(PointList[i], Line(PointList[1], PointList[end]))\\n        if (d > dmax) {\\n            index = i\\n            dmax = d\\n        }\\n    }\\n\\n    ResultList[] = empty;\\n\\n    // If max distance is greater than epsilon, recursively simplify\\n    if (dmax > epsilon) {\\n        // Recursive call\\n        recResults1[] = DouglasPeucker(PointList[1...index], epsilon)\\n        recResults2[] = DouglasPeucker(PointList[index...end], epsilon)\\n\\n        // Build the result list\\n        ResultList[] = {recResults1[1...length(recResults1) - 1], recResults2[1...length(recResults2)]}\\n    } else {\\n        ResultList[] = {PointList[1], PointList[end]}\\n    }\\n    // Return the result\\n    return ResultList[]\\nend\\n\")), mdx(\"h3\", null, \"Complexity\"), mdx(\"p\", null, \"The running time of Ramer\\u2013Douglas\\u2013Peucker Algorithm when a polyline consist of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"n-1\"), \" segments and \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"n\"), \" vertices is given by the reccurence \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"T(n)=T(i+1)+T(n-i)+O(n)\"), \" where is the value of Index in peudocode.\"), mdx(\"p\", null, \"In worst case, the algorithm has a time complexity of  \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"O(n\\xB2)\"), \".\"), mdx(\"p\", null, \"In best case, it has a time complexity of \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"O(n log(n))\"), \" .\"), mdx(\"h3\", null, \"Applications\"), mdx(\"p\", null, \"This algorithms is used for proccessing \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"vector graphics\"), \" and and \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"cartographic generalization\"), \". It is widely used in Robotics to perform simplification and denoising of range data accquired by a rotating range scanner.\"), mdx(\"h3\", null, \"Example of Ramer\\u2013Douglas\\u2013Peucker Algorithm\"), mdx(\"iframe\", {\n    height: \"600px\",\n    width: \"100%\",\n    src: \"https://repl.it/@ayanbag/rgp-algo?lite=true\",\n    scrolling: \"no\",\n    frameBorder: \"no\",\n    allowtransparency: \"true\",\n    allowFullScreen: \"true\",\n    sandbox: \"allow-forms allow-pointer-lock allow-popups allow-same-origin allow-scripts allow-modals\"\n  }), mdx(\"p\", null, \"Download the code \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/ayanbag/rdp-algorithm\"\n  }), \"here\")));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"The  Ramer–Douglas–Peucker Algorithm  is a an algorithms that reduce the number of points that is approximated by a series of points. It is…","timeToRead":1,"banner":null}},"pageContext":{"slug":"/ramer-douglas-peucker-algorithm","formatString":"DD.MM.YYYY"}}}