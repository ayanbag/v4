{"componentChunkName":"component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx","path":"/what-is-a-algorithm","result":{"data":{"post":{"__typename":"MdxPost","slug":"/what-is-a-algorithm","title":"What is A * Algorithm ?","date":"20.06.2020","tags":[{"name":"Algorithms","slug":"algorithms"}],"description":null,"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"What is A * Algorithm ?\",\n  \"date\": \"2020-06-20T00:00:00.000Z\",\n  \"tags\": [\"Algorithms\"]\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"A * Algorithm\"), \" is one of the most popular computer algorithm widely used in Path-finding and Graph Traversal. This algorithm efficiently search and plots a path between multiple nodes, or points, on the graph. It is used in various applications, such as \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Maps\"), \".\"), mdx(\"p\", null, \"Peter Hart, Nils Nilsson and Bertram Raphael of Stanford Research Institute (now SRI International) first published the algorithm in 1968. It can be seen as an extension of Edsger Dijkstra's 1959 algorithm. \"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"A * \"), \" achieves better performance by using heuristics to guide its search. For example, on a map with many obstacles, path-finding from points \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"A\"), \" to \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"B\"), \" can be difficult. A robot, for instance, without getting much other direction, will continue until it encounters an obstacle. With \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"A * \"), \", a robot would instead find a walkable path.\"), mdx(\"h3\", null, \"Why A* Algorithm ?\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"A * \"), \" is based on using heuristic method to achieve optimality and completeness, and based the Best-First Algorithm.\"), mdx(\"p\", null, \"When a search algorithm has the property of optimality, it means it is guaranteed to find the best possible solution. When a search algorithm has the property of completeness, it means that if a solution to a given problem exists, the algorithm is guaranteed to find it.\"), mdx(\"p\", null, \"Each time \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"A* \"), \" enters a state, it calculates the cost, f(n) (n being the neighboring node), to travel to all of the neighboring nodes, and then enters the node with the lowest value of f(n).\"), mdx(\"p\", null, \"The values are calculated with the following formula :\"), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"https://user-images.githubusercontent.com/28982255/85195754-ca0e8380-b2f2-11ea-90c6-e9489433da15.png\",\n    \"alt\": null\n  }))), mdx(\"p\", null, \"where\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"g(n)\"), \" = the value of the shortest path from the start node to node n\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"h(n)\"), \" = a heuristic approximation of the node's value\")), mdx(\"p\", null, \"The efficiency  is highly dependent on the heuristic value h(n), and depending on the type of problem, we may need to use a different heuristic function for it to find the optimal solution.\"), mdx(\"p\", null, \"To understand the usage of the formula, we have to look at how the algorithm works.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Initialize the open list\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Initialize the closed list put the starting node on the open list (you can leave its f at zero)\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"while the open list is not empty\"), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"find the node with the least \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"f\"), \" on the open list, call it \\\"q\\\"\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"pop q off the open list\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"generate q's 8 successors and set their parents to q\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"for each successor\"), mdx(\"ol\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"if successor is the goal, stop search successor.\", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"g\"), \" = q.\", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"g\"), \" + distance between successor and q \"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"successor.\", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"h\"), \" = distance from goal to successor   \"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"successor.\", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"f\"), \" = successor.\", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"g\"), \" + successor.\", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"h\"))), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"if a node with the same position as successor is in the OPEN list which has a lower \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"f\"), \" than successor, skip this successor\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"if a node with the same position as successor  is in the CLOSED list which has a lower f than successor, skip this successor otherwise, add  the node to the open list end (for loop)\")))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"push q on the closed list end (while loop) \"))))), mdx(\"h3\", null, \"Heuristic\"), mdx(\"p\", null, \"To calculate the value of \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"h\"), \", we can do two things :\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Calculate the exact value of \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"h\"), \" (Time Consuming method), OR\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Approximate the value of \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"h\"), \" using some heuristics (Less Time Consuming)\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Exact Heuristics - \")), mdx(\"p\", null, \"To calculate the exact value of \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"h\"), \" , firstly we have to pre-compute the distance between each pair of cells before running \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"A * \"), \" algorithm.\"), mdx(\"p\", null, \"If there are no blocked cells, then we can just find the exact value of \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"h\"), \" without any pre-computation using Distance Formula.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \" Approximation Heuristics - \")), mdx(\"p\", null, \"There are three approximation heuristics to calculate \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"h\"), \" :\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Manhattan Distance\"), \" \")), mdx(\"p\", null, \"It is the sum of absolute values of differences in the goal\\u2019s x and y coordinates and the current cell\\u2019s x and y coordinates respectively, i.e.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"h = abs (current_cell.x \\u2013 goal.x) + abs (current_cell.y \\u2013 goal.y) \\n\")), mdx(\"p\", null, \"This type of heuristic is used, only when we allowed to move in four direction.\"), mdx(\"ol\", {\n    \"start\": 2\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Diagonal Distance\"))), mdx(\"p\", null, \"It is the maximum of absolute values of differences in the goal\\u2019s x and y coordinates and the current cell\\u2019s x and y coordinates respectively, i.e.,\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \" h = max { abs(current_cell.x \\u2013 goal.x), abs(current_cell.y \\u2013 goal.y) } \\n\")), mdx(\"p\", null, \"It is used only when we are alowed to move in \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"eight\"), \" direction only.\"), mdx(\"ol\", {\n    \"start\": 3\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Euclidean Distance\"))), mdx(\"p\", null, \"It is the distance between the current cell and the goal cell using the distance formula.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"h = sqrt ( (current_cell.x \\u2013 goal.x) ^ 2 + (current_cell.y \\u2013 goal.y) ^ 2 ) \\n\")), mdx(\"p\", null, \"It is used when we are allowed to move in \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"all\"), \" direction.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Dijkstra is a special case of A* Search Algorithm, where h = 0 for all nodes.\")));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"A * Algorithm  is one of the most popular computer algorithm widely used in Path-finding and Graph Traversal. This algorithm efficientlyâ€¦","timeToRead":3,"banner":null}},"pageContext":{"slug":"/what-is-a-algorithm","formatString":"DD.MM.YYYY"}}}