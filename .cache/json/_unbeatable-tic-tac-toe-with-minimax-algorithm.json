{"data":{"post":{"__typename":"MdxPost","slug":"/unbeatable-tic-tac-toe-with-minimax-algorithm","title":"Unbeatable Tic-Tac-Toe with Minimax Algorithm","date":"02.06.2020","tags":[{"name":"Algorithms","slug":"algorithms"},{"name":"Machine Learning","slug":"machine-learning"}],"description":null,"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Unbeatable Tic-Tac-Toe with Minimax Algorithm\",\n  \"date\": \"2020-06-02T00:00:00.000Z\",\n  \"tags\": [\"Algorithms\", \"Machine Learning\"]\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Since the advent of Artificial Algorithms, the game playing has been one of the most interesting part of Artificial Intelligence. In 1947, a computer named \\\"Deep Blue\\\" defeated reigning world chess champion Garry Kasprov is a defining moment in the history of AI. But the great minds behind this computer started investing and publishing in this subject nearly six decades earlier. \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Alan Turing\"), \" known as the father of theoretical algorithm and artificial intelligence is credited with provoking the investigation dating all the way back to the 1940s.\"), mdx(\"p\", null, \"Games such as chess, tic-tac-toe, and Go are interesting because they offer a pure abstraction of the competition between the two armies and this abstraction makes games playing an attractive area for AI research.\"), mdx(\"p\", null, \"However, this article will focus on one of the general decision-making strategy used by computers across a variety of strategic games, like Chess , checkers and many more.\"), mdx(\"p\", null, \"This general-strategy is a widely used algorithm in game theory, called the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Minimax Algorithm\"), \".\"), mdx(\"h3\", null, \"What is Minimax Algorithm ?\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Minimax\"), \" is a kind of backtracking algorithm that is used in decision making and game theory to choose an optimal move for a player assuming that the opponent is also playing optimally.\"), mdx(\"p\", null, \"The theory behind the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Minimax Algorithm\"), \" is that the algorithm's opponents will try to minimize whatever value the algorithm is trying to maximize. Thus, the computer should make moves which leaves its opponent capable of doing the least damage.\"), mdx(\"p\", null, \"In ideal case i.e, the computer has infinite time and infinite storage capacity, the computer will investigate every possible outcome from the game current state as well as the path taken to reach the those states and assign those outcomes value. For a win-or-lose game like chess or tic-tac-toe, there are only three possible values-win, lose, or draw (often assigned numeric values of 1, -1, and 0 respectively)--but for other games like backgammon or poker with a \\\"score\\\" to maximize, the scores themselves are used. Then the computer evaluates which is the best possible outcome for the computer's opponents, starting bottom. By assuming that if the game state is reached, its opponent will make move which will lead to the opponent's best outcome which is the worse for the computer. Thus it knows its opponents future moves, and have a concrete idea of what the final state of the game will be if the second-last-position is reached. Then, the computer will treat that position of the terminal node of that value, even though it is not actually a terminal value. This process repeated a level higher, and so on. Ultimately, the computer has all the options available in which it can assign a value and the computer simply picks the highest value and takes action.\"), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"https://user-images.githubusercontent.com/28982255/83515724-7975e880-a4f3-11ea-9630-a41f21d9a103.gif\",\n    \"alt\": null\n  }))), mdx(\"h3\", null, \"Coding an unbeatable Tic Tac Toe AI\"), mdx(\"p\", null, \"In our excecution of Minimax algorithm for building an AI to solve Tic-Tac-Toe, it works by visuallizing all future possible states of the board and constructs it in the form of a tree. When the current board is given to the algorithm i.e the roots of the tree, it splits into 'n' branches (where n denotes the number of move that can be choosen by the algorithm). If any of these news states is a terminal state, no further splits are performed for this state and it is assigned a score in the following way : \"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Score = +1 (if the computer wins)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Score = -1 (if the computer loses)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Score = 0 (if a draw happens)\")), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"https://user-images.githubusercontent.com/28982255/83522588-82b88280-a4fe-11ea-975e-44dd1a632214.png\",\n    \"alt\": null\n  }))), mdx(\"p\", null, \"However if there is no terminal states, then each of this new states is considered as new roots and they give rise a tree of thier own. Being a 2 player game, player take turn alternatively, therefore whenever we go one level deeper in the network, we need to change the player which would be placed in one of the empty cell. By this way, we can visualize the moves of our opponent as result of our moves. The algorithm will evaluate the best move to be choose so that it will gain a maximum score when it is the computer's turn and the minimum score when it is its opponent's/human's turn.\"), mdx(\"p\", null, \"The Code of Tic-Tac-Toe :\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\"\n  }), \"# Import libraries\\nimport sys\\nimport random\\n\\n# This class represent a tic tac to game\\nclass TicTacToeGame:\\n\\n    # Create a new game\\n    def __init__(self, rows:int, columns:int, goal:int, max_depth:int=4):\\n        \\n        # Create the game state\\n        self.state = []\\n        self.tiles = {}\\n        self.inverted_tiles = {}\\n        tile = 0\\n        for y in range(rows):\\n            row = []\\n            for x in range(columns):\\n                row += '.'\\n                tile += 1\\n                self.tiles[tile] = (y, x)\\n                self.inverted_tiles[(y, x)] = tile\\n            self.state.append(row)\\n\\n        # Set the number of noughts and crosses in a row that is needed to win the game\\n        self.goal = goal\\n\\n        # Create vectors\\n        self.vectors = [(1,0), (0,1), (1,1), (-1,1)]\\n\\n        # Set lengths\\n        self.rows = rows\\n        self.columns = columns\\n        self.max_row_index = rows - 1\\n        self.max_columns_index = columns - 1\\n        self.max_depth = max_depth\\n\\n        # Heuristics for cutoff\\n        self.winning_positions = []\\n        self.get_winning_positions()\\n\\n        # Set the starting player at random\\n        #self.player = 'O'\\n        self.player = random.choice(['X', 'O'])\\n\\n    # Get winning positions\\n    def get_winning_positions(self):\\n\\n        # Loop the board\\n        for y in range(self.rows):\\n            for x in range(self.columns):\\n                \\n                # Loop vectors\\n                for vector in self.vectors:\\n                    \\n                    # Get the start position\\n                    sy, sx = (y, x)\\n\\n                    # Get vector deltas\\n                    dy, dx = vector\\n\\n                    # Create a counter\\n                    counter = 0\\n\\n                    # Loop until we are outside the board\\n                    positions = []\\n                    while True:\\n\\n                        # Add the position\\n                        positions.append(self.inverted_tiles.get((sy, sx)))\\n\\n                        # Check if we have a winning position\\n                        if (len(positions) == self.goal):\\n\\n                            # Add winning positions\\n                            self.winning_positions.append(positions)\\n\\n                            # Break out from the loop\\n                            break\\n\\n                        # Update the position\\n                        sy += dy\\n                        sx += dx\\n                \\n                        # Check if the loop should terminate\\n                        if(sy < 0 or abs(sy) > self.max_row_index or sx < 0 or abs(sx) > self.max_columns_index):\\n                            break\\n\\n    # Play the game\\n    def play(self):\\n\\n        # Variables\\n        result = None\\n\\n        # Create an infinite loop\\n        print('Starting board')\\n        while True:\\n\\n            # Draw the state\\n            self.print_state()\\n\\n            # Get a move from a player\\n            if (self.player == 'X'): # AI\\n\\n                # Print AI move\\n                print('Player X moving (AI) ...')\\n\\n                # Get the best move\\n                max, py, px, depth = self.max(-sys.maxsize, sys.maxsize)\\n\\n                # Get a heuristic move at cutoff\\n                print('Depth: {0}'.format(depth))\\n                if(depth > self.max_depth):\\n                    py, px = self.get_best_move()\\n\\n                # Make a move\\n                self.state[py][px] = 'X'\\n\\n                # Check if the game has ended, break out from the loop in that case\\n                result = self.game_ended()\\n                if(result != None):\\n                    break\\n\\n                # Change turn\\n                self.player = 'O'\\n\\n            elif (self.player == 'O'): # Human player\\n                \\n                # Print turn\\n                print('Player O moving (Human) ...')\\n\\n                # Get a recommended move\\n                min, py, px, depth = self.min(-sys.maxsize, sys.maxsize)\\n\\n                # Get a heuristic move at cutoff\\n                print('Depth: {0}'.format(depth))\\n                if(depth > self.max_depth):\\n                    py, px = self.get_best_move()\\n\\n                # Print a recommendation\\n                print('Recommendation: {0}'.format(self.inverted_tiles.get((py, px))))\\n\\n                # Get input\\n                number = int(input('Make a move (tile number): '))\\n                tile = self.tiles.get(number)\\n\\n                # Check if the move is legal\\n                if(tile != None):\\n                    \\n                    # Make a move\\n                    py, px = tile\\n                    self.state[py][px] = 'O'\\n\\n                    # Check if the game has ended, break out from the loop in that case\\n                    result = self.game_ended()\\n                    if(result != None):\\n                        break\\n\\n                    # Change turn\\n                    self.player = 'X'\\n\\n                else:\\n                    print('Move is not legal, try again.')\\n\\n        # Print result\\n        self.print_state()\\n        print('Winner is player: {0}'.format(result))\\n\\n    # An evaluation function to get the best move based on heuristics\\n    def get_best_move(self):\\n\\n        # Create an heuristic dictionary\\n        heuristics = {}\\n\\n        # Get all empty cells\\n        empty_cells = []\\n        for y in range(self.rows):\\n            for x in range(self.columns):\\n                if (self.state[y][x] == '.'):\\n                    empty_cells.append((y, x))\\n\\n        # Loop empty positions\\n        for empty in empty_cells:\\n\\n            # Get numbered position\\n            number = self.inverted_tiles.get(empty)\\n\\n            # Loop winning positions\\n            for win in self.winning_positions:\\n\\n                # Check if number is in a winning position\\n                if(number in win):\\n\\n                    # Calculate the number of X:s and O:s in the winning position\\n                    player_x = 0\\n                    player_o = 0\\n                    start_score = 1\\n                    for box in win:\\n\\n                        # Get the position\\n                        y, x = self.tiles[box]\\n\\n                        # Count X:s and O:s\\n                        if(self.state[y][x] == 'X'):\\n                            player_x += start_score if self.player == 'X' else start_score * 2\\n                            start_score *= 10\\n                        elif (self.state[y][x] == 'O'):\\n                            player_o += start_score if self.player == 'O' else start_score * 2\\n                            start_score *= 10\\n\\n                    # Save heuristic\\n                    if(player_x == 0 or player_o == 0):\\n\\n                        # Calculate a score\\n                        score = max(player_x, player_o) + start_score\\n\\n                        # Update the score\\n                        if(heuristics.get(number) != None):\\n                            heuristics[number] += score\\n                        else:\\n                            heuristics[number] = score\\n\\n        # Get the best move from the heuristic dictionary\\n        best_move = random.choice(empty_cells)\\n        best_count = -sys.maxsize\\n        for key, value in heuristics.items():\\n            if(value > best_count):\\n                best_move = self.tiles.get(key)\\n                best_count = value\\n\\n        # Return the best move\\n        return best_move\\n\\n    # Check if the game has ended\\n    def game_ended(self) -> str:\\n\\n        # Check if a player has won\\n        result = self.player_has_won()\\n        if(result != None):\\n            return result\\n\\n        # Check if the board is full\\n        for y in range(self.rows):\\n            for x in range(self.columns):\\n                if (self.state[y][x] == '.'):\\n                    return None\\n\\n        # Return a tie\\n        return 'It is a tie!'\\n       \\n    # Check if a player has won\\n    def player_has_won(self) -> str:\\n        \\n        # Loop the board\\n        for y in range(self.rows):\\n            for x in range(self.columns):\\n                \\n                # Loop vectors\\n                for vector in self.vectors:\\n                    \\n                    # Get the start position\\n                    sy, sx = (y, x)\\n\\n                    # Get vector deltas\\n                    dy, dx = vector\\n\\n                    # Create counters\\n                    steps = 0\\n                    player_x = 0\\n                    player_o = 0\\n\\n                    # Loop until we are outside the board or have moved the number of steps in the goal\\n                    while steps < self.goal:\\n\\n                        # Add steps\\n                        steps += 1\\n\\n                        # Check if a player has a piece in the tile\\n                        if(self.state[sy][sx] == 'X'):\\n                            player_x += 1\\n                        elif(self.state[sy][sx] == 'O'):\\n                            player_o += 1\\n\\n                        # Update the position\\n                        sy += dy\\n                        sx += dx\\n                \\n                        # Check if the loop should terminate\\n                        if(sy < 0 or abs(sy) > self.max_row_index or sx < 0 or abs(sx) > self.max_columns_index):\\n                            break\\n\\n                    # Check if we have a winner\\n                    if(player_x >= self.goal):\\n                        return 'X'\\n                    elif(player_o >= self.goal):\\n                        return 'O'\\n\\n        # Return None if no winner is found\\n        return None\\n\\n    # Get a min value (O)\\n    def min(self, alpha:int=-sys.maxsize, beta:int=sys.maxsize, depth:int=0):\\n        \\n        # Variables\\n        min_value = sys.maxsize\\n        by = None\\n        bx = None\\n        \\n        # Check if the game has ended\\n        result = self.game_ended()\\n        if(result != None):\\n            if result == 'X':\\n                return 1, 0, 0, depth\\n            elif result == 'O':\\n                return -1, 0, 0, depth\\n            elif result == 'It is a tie!':\\n                return 0, 0, 0, depth\\n        elif(depth > self.max_depth):\\n            return 0, 0, 0, depth\\n\\n        # Loop the board\\n        for y in range(self.rows):\\n            for x in range(self.columns):\\n\\n                # Check if the tile is empty\\n                if (self.state[y][x] == '.'):\\n\\n                    # Make a move\\n                    self.state[y][x] = 'O'\\n\\n                    # Get max value\\n                    max, max_y, max_x, depth = self.max(alpha, beta, depth + 1)\\n                    \\n                    # Set min value to max value if it is lower than curren min value\\n                    if (max < min_value):\\n                        min_value = max\\n                        by = y\\n                        bx = x\\n                        \\n                    # Reset the tile\\n                    self.state[y][x] = '.'\\n\\n                    # Do an alpha test\\n                    if (min_value <= alpha):\\n                        return min_value, bx, by, depth\\n\\n                    # Do a beta test\\n                    if (min_value < beta):\\n                        beta = min_value\\n\\n        # Return min value\\n        return min_value, by, bx, depth\\n\\n    # Get max value (X)\\n    def max(self, alpha:int=-sys.maxsize, beta:int=sys.maxsize, depth:int=0):\\n\\n        # Variables\\n        max_value = -sys.maxsize\\n        by = None\\n        bx = None\\n\\n        # Check if the game has ended\\n        result = self.game_ended()\\n        if(result != None):\\n            if result == 'X':\\n                return 1, 0, 0, depth\\n            elif result == 'O':\\n                return -1, 0, 0, depth\\n            elif result == 'It is a tie!':\\n                return 0, 0, 0, depth\\n        elif(depth > self.max_depth):\\n            return 0, 0, 0, depth\\n\\n        # Loop the board\\n        for y in range(self.rows):\\n            for x in range(self.columns):\\n\\n                # Check if the current tile is empty\\n                if (self.state[y][x] == '.'):\\n                    \\n                    # Add a piece to the board\\n                    self.state[y][x] = 'X'\\n\\n                    # Set max value to min value if min value is greater than current max value\\n                    min, min_y, min_x, depth = self.min(alpha, beta, depth + 1)\\n\\n                    # Adjust the max value\\n                    if (min > max_value):\\n                        max_value = min\\n                        by = y\\n                        bx = x\\n\\n                    # Reset the tile\\n                    self.state[y][x] = '.'\\n\\n                    # Do a beta test\\n                    if (max_value >= beta):\\n                        return max_value, bx, by, depth\\n\\n                    # Do an alpha test\\n                    if (max_value > alpha):\\n                        alpha = max_value\\n\\n        # Return max value\\n        return max_value, by, bx, depth\\n\\n    # Print the current game state\\n    def print_state(self):\\n        for y in range(self.rows):\\n            print('| ', end='')\\n            for x in range(self.columns):\\n                if (self.state[y][x] != '.'):\\n                    print(' {0}  | '.format(self.state[y][x]), end='')\\n                else:\\n                    digit = str(self.inverted_tiles.get((y,x))) if len(str(self.inverted_tiles.get((y,x)))) > 1 else ' ' + str(self.inverted_tiles.get((y,x)))\\n                    print('{0}  | '.format(digit), end='')\\n            print()\\n        print()\\n\\n# The main entry point for this module\\ndef main():\\n\\n    # Create a game\\n    #game = TicTacToeGame(7, 6, 4, 1000)\\n    game = TicTacToeGame(3, 3, 3, 1000)\\n\\n    # Play the game\\n    game.play()\\n\\n# Tell python to run main method\\nif __name__ == \\\"__main__\\\": main()\\n\")), mdx(\"h3\", null, \"Live Code\"), mdx(\"iframe\", {\n    height: \"550px\",\n    width: \"100%\",\n    src: \"https://repl.it/@ayanbag/tictactoe?lite=true\",\n    scrolling: \"no\",\n    frameBorder: \"no\",\n    allowtransparency: \"true\",\n    allowFullScreen: \"true\",\n    sandbox: \"allow-forms allow-pointer-lock allow-popups allow-same-origin allow-scripts allow-modals\"\n  }), mdx(\"h3\", null, \"Helpfull Resources\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://www.neverstopbuilding.com/blog/minimax\"\n  }), \"https://www.neverstopbuilding.com/blog/minimax\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://www.freecodecamp.org/news/how-to-make-your-tic-tac-toe-game-unbeatable-by-using-the-minimax-algorithm-9d690bad4b37/\"\n  }), \"https://www.freecodecamp.org/news/how-to-make-your-tic-tac-toe-game-unbeatable-by-using-the-minimax-algorithm-9d690bad4b37/\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"http://www.shei.io/recursion-minimax-algorithm/\"\n  }), \"http://www.shei.io/recursion-minimax-algorithm/\"))));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"Since the advent of Artificial Algorithms, the game playing has been one of the most interesting part of Artificial Intelligence. In 1947, a…","timeToRead":3,"banner":null}},"pageContext":{"slug":"/unbeatable-tic-tac-toe-with-minimax-algorithm","formatString":"DD.MM.YYYY"}}