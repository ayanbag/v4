{"expireTime":9007200865547474000,"key":"gatsby-plugin-mdx-entire-payload-4505bcfda3d089e2ec69da2118d820f7-","val":{"mdast":{"type":"root","children":[{"type":"paragraph","children":[{"type":"text","value":"The ","position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":5,"offset":5},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"Ramer–Douglas–Peucker Algorithm","position":{"start":{"line":2,"column":7,"offset":7},"end":{"line":2,"column":38,"offset":38},"indent":[]}}],"position":{"start":{"line":2,"column":5,"offset":5},"end":{"line":2,"column":40,"offset":40},"indent":[]}},{"type":"text","value":" is a an algorithms that reduce the number of points that is approximated by a series of points. It is also known as the ","position":{"start":{"line":2,"column":40,"offset":40},"end":{"line":2,"column":161,"offset":161},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"Douglas–Peucker algorithm","position":{"start":{"line":2,"column":163,"offset":163},"end":{"line":2,"column":188,"offset":188},"indent":[]}}],"position":{"start":{"line":2,"column":161,"offset":161},"end":{"line":2,"column":190,"offset":190},"indent":[]}},{"type":"text","value":" and ","position":{"start":{"line":2,"column":190,"offset":190},"end":{"line":2,"column":195,"offset":195},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"iterative end-point fit algorithm","position":{"start":{"line":2,"column":197,"offset":197},"end":{"line":2,"column":230,"offset":230},"indent":[]}}],"position":{"start":{"line":2,"column":195,"offset":195},"end":{"line":2,"column":232,"offset":232},"indent":[]}},{"type":"text","value":". In simple words, it represent a complex line with fewer points in a visually proper way.","position":{"start":{"line":2,"column":232,"offset":232},"end":{"line":2,"column":322,"offset":322},"indent":[]}}],"position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":322,"offset":322},"indent":[]}},{"type":"paragraph","children":[{"type":"image","title":null,"url":"https://user-images.githubusercontent.com/28982255/82112521-2c5feb80-976b-11ea-8dbe-9b59d4b922ad.png","alt":"503cdff1-influxdata1","position":{"start":{"line":4,"column":1,"offset":324},"end":{"line":4,"column":126,"offset":449},"indent":[]}},{"type":"text","value":"\n","position":{"start":{"line":4,"column":126,"offset":449},"end":{"line":5,"column":1,"offset":450},"indent":[1]}},{"type":"emphasis","children":[{"type":"text","value":"Original dataset (right) and reduced output (left) from Ramer-Douglas-Peucker Algorithm. Image from NAMEKDEV.","position":{"start":{"line":5,"column":2,"offset":451},"end":{"line":5,"column":111,"offset":560},"indent":[]}}],"position":{"start":{"line":5,"column":1,"offset":450},"end":{"line":5,"column":112,"offset":561},"indent":[]}}],"position":{"start":{"line":4,"column":1,"offset":324},"end":{"line":5,"column":112,"offset":561},"indent":[1]}},{"type":"heading","depth":3,"children":[{"type":"text","value":"Overview","position":{"start":{"line":8,"column":5,"offset":568},"end":{"line":8,"column":13,"offset":576},"indent":[]}}],"position":{"start":{"line":8,"column":1,"offset":564},"end":{"line":8,"column":13,"offset":576},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"The main purpose of this algorithm is to find a similar curve with fewer points for a given curve composed of line segments (also called ","position":{"start":{"line":10,"column":1,"offset":578},"end":{"line":10,"column":138,"offset":715},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"Polylines","position":{"start":{"line":10,"column":140,"offset":717},"end":{"line":10,"column":149,"offset":726},"indent":[]}}],"position":{"start":{"line":10,"column":138,"offset":715},"end":{"line":10,"column":151,"offset":728},"indent":[]}},{"type":"text","value":"). This algorithm define 'disimilar' based on the maxium distance between the original curve and the simplied curve, i.e. the Hausdroff Distance. The simplified curve consist of a subset of points that defined the original curve. The Ramer–Douglas–Peucker Algorithm is most commonly used in geospatial visualizations, like Google Maps, but also useful for other in-browser visualizations as well.","position":{"start":{"line":10,"column":151,"offset":728},"end":{"line":10,"column":547,"offset":1124},"indent":[]}}],"position":{"start":{"line":10,"column":1,"offset":578},"end":{"line":10,"column":547,"offset":1124},"indent":[]}},{"type":"heading","depth":3,"children":[{"type":"text","value":"Working of Ramer–Douglas–Peucker Algorithm","position":{"start":{"line":14,"column":5,"offset":1132},"end":{"line":14,"column":47,"offset":1174},"indent":[]}}],"position":{"start":{"line":14,"column":1,"offset":1128},"end":{"line":14,"column":47,"offset":1174},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"In order to use this algorithms, the user must the epsilon ( ε ), a threshold limit that is used to determine which point to determine and discard, and it should be a value greater than zero.","position":{"start":{"line":16,"column":1,"offset":1176},"end":{"line":16,"column":192,"offset":1367},"indent":[]}}],"position":{"start":{"line":16,"column":1,"offset":1176},"end":{"line":16,"column":192,"offset":1367},"indent":[]}},{"type":"paragraph","children":[{"type":"strong","children":[{"type":"text","value":"Step-1","position":{"start":{"line":18,"column":3,"offset":1371},"end":{"line":18,"column":9,"offset":1377},"indent":[]}}],"position":{"start":{"line":18,"column":1,"offset":1369},"end":{"line":18,"column":11,"offset":1379},"indent":[]}},{"type":"text","value":" :  This algorithms stored the first and the last point of the curve and then it draws the shortest line from the bookend points.","position":{"start":{"line":18,"column":11,"offset":1379},"end":{"line":18,"column":140,"offset":1508},"indent":[]}}],"position":{"start":{"line":18,"column":1,"offset":1369},"end":{"line":18,"column":140,"offset":1508},"indent":[]}},{"type":"paragraph","children":[{"type":"image","title":null,"url":"https://user-images.githubusercontent.com/28982255/82113093-e3129a80-9770-11ea-8a47-96a5d8038546.png","alt":"c3044882-influxdata3","position":{"start":{"line":20,"column":1,"offset":1510},"end":{"line":20,"column":126,"offset":1635},"indent":[]}}],"position":{"start":{"line":20,"column":1,"offset":1510},"end":{"line":20,"column":126,"offset":1635},"indent":[]}},{"type":"paragraph","children":[{"type":"strong","children":[{"type":"text","value":"Step-2","position":{"start":{"line":24,"column":3,"offset":1641},"end":{"line":24,"column":9,"offset":1647},"indent":[]}}],"position":{"start":{"line":24,"column":1,"offset":1639},"end":{"line":24,"column":11,"offset":1649},"indent":[]}},{"type":"text","value":":  Its determine the point farthest point from the line segment with the first and last points as end points.","position":{"start":{"line":24,"column":11,"offset":1649},"end":{"line":24,"column":120,"offset":1758},"indent":[]}}],"position":{"start":{"line":24,"column":1,"offset":1639},"end":{"line":24,"column":120,"offset":1758},"indent":[]}},{"type":"paragraph","children":[{"type":"image","title":null,"url":"https://user-images.githubusercontent.com/28982255/82113113-fcb3e200-9770-11ea-828b-7b90e7a3db5e.png","alt":"473bcfba-influxdata4","position":{"start":{"line":26,"column":1,"offset":1760},"end":{"line":26,"column":126,"offset":1885},"indent":[]}}],"position":{"start":{"line":26,"column":1,"offset":1760},"end":{"line":26,"column":126,"offset":1885},"indent":[]}},{"type":"paragraph","children":[{"type":"strong","children":[{"type":"text","value":"Step-3","position":{"start":{"line":30,"column":3,"offset":1891},"end":{"line":30,"column":9,"offset":1897},"indent":[]}}],"position":{"start":{"line":30,"column":1,"offset":1889},"end":{"line":30,"column":11,"offset":1899},"indent":[]}},{"type":"text","value":": Any points within the epsilon distance from this line will be removed and the approximation will be drawn.","position":{"start":{"line":30,"column":11,"offset":1899},"end":{"line":30,"column":119,"offset":2007},"indent":[]}}],"position":{"start":{"line":30,"column":1,"offset":1889},"end":{"line":30,"column":119,"offset":2007},"indent":[]}},{"type":"paragraph","children":[{"type":"image","title":null,"url":"https://user-images.githubusercontent.com/28982255/82113127-17865680-9771-11ea-9eee-734a77da4f58.png","alt":"bd5f4e41-influxdata5","position":{"start":{"line":32,"column":1,"offset":2009},"end":{"line":32,"column":126,"offset":2134},"indent":[]}}],"position":{"start":{"line":32,"column":1,"offset":2009},"end":{"line":32,"column":126,"offset":2134},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"The process repeats recurcively until the new approximation for the polyline has been formed.","position":{"start":{"line":35,"column":1,"offset":2137},"end":{"line":35,"column":94,"offset":2230},"indent":[]}}],"position":{"start":{"line":35,"column":1,"offset":2137},"end":{"line":35,"column":94,"offset":2230},"indent":[]}},{"type":"paragraph","children":[{"type":"image","title":null,"url":"https://user-images.githubusercontent.com/28982255/82113279-7ef0d600-9772-11ea-84c5-0e28e4938f38.gif","alt":"rdp","position":{"start":{"line":37,"column":1,"offset":2232},"end":{"line":37,"column":109,"offset":2340},"indent":[]}}],"position":{"start":{"line":37,"column":1,"offset":2232},"end":{"line":37,"column":109,"offset":2340},"indent":[]}},{"type":"heading","depth":3,"children":[{"type":"text","value":"Pseudocode","position":{"start":{"line":42,"column":5,"offset":2349},"end":{"line":42,"column":15,"offset":2359},"indent":[]}}],"position":{"start":{"line":42,"column":1,"offset":2345},"end":{"line":42,"column":15,"offset":2359},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"The Pseudocode of Ramer–Douglas–Peucker Algorithm :","position":{"start":{"line":44,"column":1,"offset":2361},"end":{"line":44,"column":52,"offset":2412},"indent":[]}}],"position":{"start":{"line":44,"column":1,"offset":2361},"end":{"line":44,"column":52,"offset":2412},"indent":[]}},{"type":"code","lang":null,"meta":null,"value":"function DouglasPeucker(PointList[], epsilon)\n    // Find the point with the maximum distance\n    dmax = 0\n    index = 0\n    end = length(PointList)\n    for i = 2 to (end - 1) {\n        d = perpendicularDistance(PointList[i], Line(PointList[1], PointList[end]))\n        if (d > dmax) {\n            index = i\n            dmax = d\n        }\n    }\n\n    ResultList[] = empty;\n\n    // If max distance is greater than epsilon, recursively simplify\n    if (dmax > epsilon) {\n        // Recursive call\n        recResults1[] = DouglasPeucker(PointList[1...index], epsilon)\n        recResults2[] = DouglasPeucker(PointList[index...end], epsilon)\n\n        // Build the result list\n        ResultList[] = {recResults1[1...length(recResults1) - 1], recResults2[1...length(recResults2)]}\n    } else {\n        ResultList[] = {PointList[1], PointList[end]}\n    }\n    // Return the result\n    return ResultList[]\nend","position":{"start":{"line":46,"column":1,"offset":2414},"end":{"line":76,"column":4,"offset":3321},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"heading","depth":3,"children":[{"type":"text","value":"Complexity","position":{"start":{"line":80,"column":5,"offset":3329},"end":{"line":80,"column":15,"offset":3339},"indent":[]}}],"position":{"start":{"line":80,"column":1,"offset":3325},"end":{"line":80,"column":15,"offset":3339},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"The running time of Ramer–Douglas–Peucker Algorithm when a polyline consist of ","position":{"start":{"line":82,"column":1,"offset":3341},"end":{"line":82,"column":80,"offset":3420},"indent":[]}},{"type":"emphasis","children":[{"type":"text","value":"n-1","position":{"start":{"line":82,"column":81,"offset":3421},"end":{"line":82,"column":84,"offset":3424},"indent":[]}}],"position":{"start":{"line":82,"column":80,"offset":3420},"end":{"line":82,"column":85,"offset":3425},"indent":[]}},{"type":"text","value":" segments and ","position":{"start":{"line":82,"column":85,"offset":3425},"end":{"line":82,"column":99,"offset":3439},"indent":[]}},{"type":"emphasis","children":[{"type":"text","value":"n","position":{"start":{"line":82,"column":100,"offset":3440},"end":{"line":82,"column":101,"offset":3441},"indent":[]}}],"position":{"start":{"line":82,"column":99,"offset":3439},"end":{"line":82,"column":102,"offset":3442},"indent":[]}},{"type":"text","value":" vertices is given by the reccurence ","position":{"start":{"line":82,"column":102,"offset":3442},"end":{"line":82,"column":139,"offset":3479},"indent":[]}},{"type":"emphasis","children":[{"type":"text","value":"T(n)=T(i+1)+T(n-i)+O(n)","position":{"start":{"line":82,"column":140,"offset":3480},"end":{"line":82,"column":163,"offset":3503},"indent":[]}}],"position":{"start":{"line":82,"column":139,"offset":3479},"end":{"line":82,"column":164,"offset":3504},"indent":[]}},{"type":"text","value":" where is the value of Index in peudocode.","position":{"start":{"line":82,"column":164,"offset":3504},"end":{"line":82,"column":206,"offset":3546},"indent":[]}}],"position":{"start":{"line":82,"column":1,"offset":3341},"end":{"line":82,"column":206,"offset":3546},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"In worst case, the algorithm has a time complexity of  ","position":{"start":{"line":84,"column":1,"offset":3548},"end":{"line":84,"column":56,"offset":3603},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"O(n²)","position":{"start":{"line":84,"column":58,"offset":3605},"end":{"line":84,"column":63,"offset":3610},"indent":[]}}],"position":{"start":{"line":84,"column":56,"offset":3603},"end":{"line":84,"column":65,"offset":3612},"indent":[]}},{"type":"text","value":".","position":{"start":{"line":84,"column":65,"offset":3612},"end":{"line":84,"column":66,"offset":3613},"indent":[]}}],"position":{"start":{"line":84,"column":1,"offset":3548},"end":{"line":84,"column":66,"offset":3613},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"In best case, it has a time complexity of ","position":{"start":{"line":86,"column":1,"offset":3615},"end":{"line":86,"column":43,"offset":3657},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"O(n log(n))","position":{"start":{"line":86,"column":45,"offset":3659},"end":{"line":86,"column":56,"offset":3670},"indent":[]}}],"position":{"start":{"line":86,"column":43,"offset":3657},"end":{"line":86,"column":58,"offset":3672},"indent":[]}},{"type":"text","value":" .","position":{"start":{"line":86,"column":58,"offset":3672},"end":{"line":86,"column":60,"offset":3674},"indent":[]}}],"position":{"start":{"line":86,"column":1,"offset":3615},"end":{"line":86,"column":60,"offset":3674},"indent":[]}},{"type":"heading","depth":3,"children":[{"type":"text","value":"Applications","position":{"start":{"line":89,"column":5,"offset":3681},"end":{"line":89,"column":17,"offset":3693},"indent":[]}}],"position":{"start":{"line":89,"column":1,"offset":3677},"end":{"line":89,"column":17,"offset":3693},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"This algorithms is used for proccessing ","position":{"start":{"line":91,"column":1,"offset":3695},"end":{"line":91,"column":41,"offset":3735},"indent":[]}},{"type":"emphasis","children":[{"type":"text","value":"vector graphics","position":{"start":{"line":91,"column":42,"offset":3736},"end":{"line":91,"column":57,"offset":3751},"indent":[]}}],"position":{"start":{"line":91,"column":41,"offset":3735},"end":{"line":91,"column":58,"offset":3752},"indent":[]}},{"type":"text","value":" and and ","position":{"start":{"line":91,"column":58,"offset":3752},"end":{"line":91,"column":67,"offset":3761},"indent":[]}},{"type":"emphasis","children":[{"type":"text","value":"cartographic generalization","position":{"start":{"line":91,"column":68,"offset":3762},"end":{"line":91,"column":95,"offset":3789},"indent":[]}}],"position":{"start":{"line":91,"column":67,"offset":3761},"end":{"line":91,"column":96,"offset":3790},"indent":[]}},{"type":"text","value":". It is widely used in Robotics to perform simplification and denoising of range data accquired by a rotating range scanner.","position":{"start":{"line":91,"column":96,"offset":3790},"end":{"line":91,"column":220,"offset":3914},"indent":[]}}],"position":{"start":{"line":91,"column":1,"offset":3695},"end":{"line":91,"column":220,"offset":3914},"indent":[]}},{"type":"heading","depth":3,"children":[{"type":"text","value":"Example of Ramer–Douglas–Peucker Algorithm","position":{"start":{"line":94,"column":5,"offset":3921},"end":{"line":94,"column":47,"offset":3963},"indent":[]}}],"position":{"start":{"line":94,"column":1,"offset":3917},"end":{"line":94,"column":47,"offset":3963},"indent":[]}},{"type":"jsx","value":"<iframe height=\"600px\" width=\"100%\" src=\"https://repl.it/@ayanbag/rgp-algo?lite=true\" scrolling=\"no\" frameborder=\"no\" allowtransparency=\"true\" allowfullscreen=\"true\" sandbox=\"allow-forms allow-pointer-lock allow-popups allow-same-origin allow-scripts allow-modals\"></iframe>","position":{"start":{"line":99,"column":1,"offset":3968},"end":{"line":99,"column":275,"offset":4242},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Download the code ","position":{"start":{"line":102,"column":1,"offset":4245},"end":{"line":102,"column":19,"offset":4263},"indent":[]}},{"type":"link","title":null,"url":"https://github.com/ayanbag/rdp-algorithm","children":[{"type":"text","value":"here","position":{"start":{"line":102,"column":20,"offset":4264},"end":{"line":102,"column":24,"offset":4268},"indent":[]}}],"position":{"start":{"line":102,"column":19,"offset":4263},"end":{"line":102,"column":67,"offset":4311},"indent":[]}}],"position":{"start":{"line":102,"column":1,"offset":4245},"end":{"line":102,"column":67,"offset":4311},"indent":[]}},{"type":"export","value":"export const _frontmatter = {\"title\":\"Ramer–Douglas–Peucker Algorithm\",\"date\":\"2020-05-16T00:00:00.000Z\",\"tags\":[\"Algorithms\"]}","position":{"start":{"line":104,"column":1,"offset":4313},"end":{"line":104,"column":128,"offset":4440},"indent":[]}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":104,"column":128,"offset":4440}}},"scopeImports":["import * as React from 'react'"],"scopeIdentifiers":["React"],"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Ramer–Douglas–Peucker Algorithm\",\n  \"date\": \"2020-05-16T00:00:00.000Z\",\n  \"tags\": [\"Algorithms\"]\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"The \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Ramer\\u2013Douglas\\u2013Peucker Algorithm\"), \" is a an algorithms that reduce the number of points that is approximated by a series of points. It is also known as the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Douglas\\u2013Peucker algorithm\"), \" and \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"iterative end-point fit algorithm\"), \". In simple words, it represent a complex line with fewer points in a visually proper way.\"), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"https://user-images.githubusercontent.com/28982255/82112521-2c5feb80-976b-11ea-8dbe-9b59d4b922ad.png\",\n    \"alt\": \"503cdff1-influxdata1\"\n  })), \"\\n\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Original dataset (right) and reduced output (left) from Ramer-Douglas-Peucker Algorithm. Image from NAMEKDEV.\")), mdx(\"h3\", null, \"Overview\"), mdx(\"p\", null, \"The main purpose of this algorithm is to find a similar curve with fewer points for a given curve composed of line segments (also called \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Polylines\"), \"). This algorithm define 'disimilar' based on the maxium distance between the original curve and the simplied curve, i.e. the Hausdroff Distance. The simplified curve consist of a subset of points that defined the original curve. The Ramer\\u2013Douglas\\u2013Peucker Algorithm is most commonly used in geospatial visualizations, like Google Maps, but also useful for other in-browser visualizations as well.\"), mdx(\"h3\", null, \"Working of Ramer\\u2013Douglas\\u2013Peucker Algorithm\"), mdx(\"p\", null, \"In order to use this algorithms, the user must the epsilon ( \\u03B5 ), a threshold limit that is used to determine which point to determine and discard, and it should be a value greater than zero.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Step-1\"), \" :  This algorithms stored the first and the last point of the curve and then it draws the shortest line from the bookend points.\"), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"https://user-images.githubusercontent.com/28982255/82113093-e3129a80-9770-11ea-8a47-96a5d8038546.png\",\n    \"alt\": \"c3044882-influxdata3\"\n  }))), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Step-2\"), \":  Its determine the point farthest point from the line segment with the first and last points as end points.\"), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"https://user-images.githubusercontent.com/28982255/82113113-fcb3e200-9770-11ea-828b-7b90e7a3db5e.png\",\n    \"alt\": \"473bcfba-influxdata4\"\n  }))), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Step-3\"), \": Any points within the epsilon distance from this line will be removed and the approximation will be drawn.\"), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"https://user-images.githubusercontent.com/28982255/82113127-17865680-9771-11ea-9eee-734a77da4f58.png\",\n    \"alt\": \"bd5f4e41-influxdata5\"\n  }))), mdx(\"p\", null, \"The process repeats recurcively until the new approximation for the polyline has been formed.\"), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"https://user-images.githubusercontent.com/28982255/82113279-7ef0d600-9772-11ea-84c5-0e28e4938f38.gif\",\n    \"alt\": \"rdp\"\n  }))), mdx(\"h3\", null, \"Pseudocode\"), mdx(\"p\", null, \"The Pseudocode of Ramer\\u2013Douglas\\u2013Peucker Algorithm :\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"function DouglasPeucker(PointList[], epsilon)\\n    // Find the point with the maximum distance\\n    dmax = 0\\n    index = 0\\n    end = length(PointList)\\n    for i = 2 to (end - 1) {\\n        d = perpendicularDistance(PointList[i], Line(PointList[1], PointList[end]))\\n        if (d > dmax) {\\n            index = i\\n            dmax = d\\n        }\\n    }\\n\\n    ResultList[] = empty;\\n\\n    // If max distance is greater than epsilon, recursively simplify\\n    if (dmax > epsilon) {\\n        // Recursive call\\n        recResults1[] = DouglasPeucker(PointList[1...index], epsilon)\\n        recResults2[] = DouglasPeucker(PointList[index...end], epsilon)\\n\\n        // Build the result list\\n        ResultList[] = {recResults1[1...length(recResults1) - 1], recResults2[1...length(recResults2)]}\\n    } else {\\n        ResultList[] = {PointList[1], PointList[end]}\\n    }\\n    // Return the result\\n    return ResultList[]\\nend\\n\")), mdx(\"h3\", null, \"Complexity\"), mdx(\"p\", null, \"The running time of Ramer\\u2013Douglas\\u2013Peucker Algorithm when a polyline consist of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"n-1\"), \" segments and \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"n\"), \" vertices is given by the reccurence \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"T(n)=T(i+1)+T(n-i)+O(n)\"), \" where is the value of Index in peudocode.\"), mdx(\"p\", null, \"In worst case, the algorithm has a time complexity of  \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"O(n\\xB2)\"), \".\"), mdx(\"p\", null, \"In best case, it has a time complexity of \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"O(n log(n))\"), \" .\"), mdx(\"h3\", null, \"Applications\"), mdx(\"p\", null, \"This algorithms is used for proccessing \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"vector graphics\"), \" and and \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"cartographic generalization\"), \". It is widely used in Robotics to perform simplification and denoising of range data accquired by a rotating range scanner.\"), mdx(\"h3\", null, \"Example of Ramer\\u2013Douglas\\u2013Peucker Algorithm\"), mdx(\"iframe\", {\n    height: \"600px\",\n    width: \"100%\",\n    src: \"https://repl.it/@ayanbag/rgp-algo?lite=true\",\n    scrolling: \"no\",\n    frameBorder: \"no\",\n    allowtransparency: \"true\",\n    allowFullScreen: \"true\",\n    sandbox: \"allow-forms allow-pointer-lock allow-popups allow-same-origin allow-scripts allow-modals\"\n  }), mdx(\"p\", null, \"Download the code \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/ayanbag/rdp-algorithm\"\n  }), \"here\")));\n}\n;\nMDXContent.isMDXComponent = true;","rawMDXOutput":"/* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nexport const _frontmatter = {\n  \"title\": \"Ramer–Douglas–Peucker Algorithm\",\n  \"date\": \"2020-05-16T00:00:00.000Z\",\n  \"tags\": [\"Algorithms\"]\n};\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\")\n  return <div {...props}/>\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n    <p>{`The `}<strong parentName=\"p\">{`Ramer–Douglas–Peucker Algorithm`}</strong>{` is a an algorithms that reduce the number of points that is approximated by a series of points. It is also known as the `}<strong parentName=\"p\">{`Douglas–Peucker algorithm`}</strong>{` and `}<strong parentName=\"p\">{`iterative end-point fit algorithm`}</strong>{`. In simple words, it represent a complex line with fewer points in a visually proper way.`}</p>\n    <p><img parentName=\"p\" {...{\n        \"src\": \"https://user-images.githubusercontent.com/28982255/82112521-2c5feb80-976b-11ea-8dbe-9b59d4b922ad.png\",\n        \"alt\": \"503cdff1-influxdata1\"\n      }}></img>{`\n`}<em parentName=\"p\">{`Original dataset (right) and reduced output (left) from Ramer-Douglas-Peucker Algorithm. Image from NAMEKDEV.`}</em></p>\n    <h3>{`Overview`}</h3>\n    <p>{`The main purpose of this algorithm is to find a similar curve with fewer points for a given curve composed of line segments (also called `}<strong parentName=\"p\">{`Polylines`}</strong>{`). This algorithm define 'disimilar' based on the maxium distance between the original curve and the simplied curve, i.e. the Hausdroff Distance. The simplified curve consist of a subset of points that defined the original curve. The Ramer–Douglas–Peucker Algorithm is most commonly used in geospatial visualizations, like Google Maps, but also useful for other in-browser visualizations as well.`}</p>\n    <h3>{`Working of Ramer–Douglas–Peucker Algorithm`}</h3>\n    <p>{`In order to use this algorithms, the user must the epsilon ( ε ), a threshold limit that is used to determine which point to determine and discard, and it should be a value greater than zero.`}</p>\n    <p><strong parentName=\"p\">{`Step-1`}</strong>{` :  This algorithms stored the first and the last point of the curve and then it draws the shortest line from the bookend points.`}</p>\n    <p><img parentName=\"p\" {...{\n        \"src\": \"https://user-images.githubusercontent.com/28982255/82113093-e3129a80-9770-11ea-8a47-96a5d8038546.png\",\n        \"alt\": \"c3044882-influxdata3\"\n      }}></img></p>\n    <p><strong parentName=\"p\">{`Step-2`}</strong>{`:  Its determine the point farthest point from the line segment with the first and last points as end points.`}</p>\n    <p><img parentName=\"p\" {...{\n        \"src\": \"https://user-images.githubusercontent.com/28982255/82113113-fcb3e200-9770-11ea-828b-7b90e7a3db5e.png\",\n        \"alt\": \"473bcfba-influxdata4\"\n      }}></img></p>\n    <p><strong parentName=\"p\">{`Step-3`}</strong>{`: Any points within the epsilon distance from this line will be removed and the approximation will be drawn.`}</p>\n    <p><img parentName=\"p\" {...{\n        \"src\": \"https://user-images.githubusercontent.com/28982255/82113127-17865680-9771-11ea-9eee-734a77da4f58.png\",\n        \"alt\": \"bd5f4e41-influxdata5\"\n      }}></img></p>\n    <p>{`The process repeats recurcively until the new approximation for the polyline has been formed.`}</p>\n    <p><img parentName=\"p\" {...{\n        \"src\": \"https://user-images.githubusercontent.com/28982255/82113279-7ef0d600-9772-11ea-84c5-0e28e4938f38.gif\",\n        \"alt\": \"rdp\"\n      }}></img></p>\n    <h3>{`Pseudocode`}</h3>\n    <p>{`The Pseudocode of Ramer–Douglas–Peucker Algorithm :`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`function DouglasPeucker(PointList[], epsilon)\n    // Find the point with the maximum distance\n    dmax = 0\n    index = 0\n    end = length(PointList)\n    for i = 2 to (end - 1) {\n        d = perpendicularDistance(PointList[i], Line(PointList[1], PointList[end]))\n        if (d > dmax) {\n            index = i\n            dmax = d\n        }\n    }\n\n    ResultList[] = empty;\n\n    // If max distance is greater than epsilon, recursively simplify\n    if (dmax > epsilon) {\n        // Recursive call\n        recResults1[] = DouglasPeucker(PointList[1...index], epsilon)\n        recResults2[] = DouglasPeucker(PointList[index...end], epsilon)\n\n        // Build the result list\n        ResultList[] = {recResults1[1...length(recResults1) - 1], recResults2[1...length(recResults2)]}\n    } else {\n        ResultList[] = {PointList[1], PointList[end]}\n    }\n    // Return the result\n    return ResultList[]\nend\n`}</code></pre>\n    <h3>{`Complexity`}</h3>\n    <p>{`The running time of Ramer–Douglas–Peucker Algorithm when a polyline consist of `}<em parentName=\"p\">{`n-1`}</em>{` segments and `}<em parentName=\"p\">{`n`}</em>{` vertices is given by the reccurence `}<em parentName=\"p\">{`T(n)=T(i+1)+T(n-i)+O(n)`}</em>{` where is the value of Index in peudocode.`}</p>\n    <p>{`In worst case, the algorithm has a time complexity of  `}<strong parentName=\"p\">{`O(n²)`}</strong>{`.`}</p>\n    <p>{`In best case, it has a time complexity of `}<strong parentName=\"p\">{`O(n log(n))`}</strong>{` .`}</p>\n    <h3>{`Applications`}</h3>\n    <p>{`This algorithms is used for proccessing `}<em parentName=\"p\">{`vector graphics`}</em>{` and and `}<em parentName=\"p\">{`cartographic generalization`}</em>{`. It is widely used in Robotics to perform simplification and denoising of range data accquired by a rotating range scanner.`}</p>\n    <h3>{`Example of Ramer–Douglas–Peucker Algorithm`}</h3>\n    <iframe height=\"600px\" width=\"100%\" src=\"https://repl.it/@ayanbag/rgp-algo?lite=true\" scrolling=\"no\" frameborder=\"no\" allowtransparency=\"true\" allowfullscreen=\"true\" sandbox=\"allow-forms allow-pointer-lock allow-popups allow-same-origin allow-scripts allow-modals\"></iframe>\n    <p>{`Download the code `}<a parentName=\"p\" {...{\n        \"href\": \"https://github.com/ayanbag/rdp-algorithm\"\n      }}>{`here`}</a></p>\n\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;"}}